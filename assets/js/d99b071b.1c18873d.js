"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2241],{7016:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var o=n(4848),s=n(8453);const i={title:"Inclusive Design 2 Blog Post",slug:"/inclusive-design-2-blog-post",date:new Date("2024-10-29T20:30:00.000Z"),tags:["freeform"]},a="Inclusive Design 2 Blog Post",r={permalink:"/claire-ui-portfolio/blog/inclusive-design-2-blog-post",source:"@site/blog/InclusiveDesign2.md",title:"Inclusive Design 2 Blog Post",description:"In this chapter, one important piece of information in discusses is the four different kinds of constraints. Physical constraints limit the number of potential actions. They are most effective when they are easy to see and interpret because you want to prevent the user from even attempting the action. Cultural constraints are defined by the user\u2019s culture. They determine what actions make sense given their cultural experience. Culture is constantly evolving, and so are constraints. Semantic constraints are defined by the meaning of the situation controlling potential actions. They rely on users\u2019 knowledge of the world. These constraints can also change with time. Logical constraints are defined by what makes logical sense to the user. It has to do with the relationship between the spatial or functional layout of components. These are the four types of constraints that can be utilized by designers to make their UI more beneficial and helpful for the user.",date:"2024-10-29T20:30:00.000Z",tags:[{inline:!1,label:"FreeForm",permalink:"/claire-ui-portfolio/blog/tags/freeform",description:"Share something that captured you from the reading in any format, citing your sources."}],readingTime:.845,hasTruncateMarker:!1,authors:[],frontMatter:{title:"Inclusive Design 2 Blog Post",slug:"/inclusive-design-2-blog-post",date:"2024-10-29T20:30:00.000Z",tags:["freeform"]},unlisted:!1,prevItem:{title:"UIUN Negotiation Blog Post",permalink:"/claire-ui-portfolio/blog/uiun-negotiation-blog-post"},nextItem:{title:"Inclusive Design 1 Blog Post",permalink:"/claire-ui-portfolio/blog/inclusive-design-1-blog-post"}},l={authorsImageUrls:[]},c=[];function u(e){const t={br:"br",p:"p",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"In this chapter, one important piece of information in discusses is the four different kinds of constraints. Physical constraints limit the number of potential actions. They are most effective when they are easy to see and interpret because you want to prevent the user from even attempting the action. Cultural constraints are defined by the user\u2019s culture. They determine what actions make sense given their cultural experience. Culture is constantly evolving, and so are constraints. Semantic constraints are defined by the meaning of the situation controlling potential actions. They rely on users\u2019 knowledge of the world. These constraints can also change with time. Logical constraints are defined by what makes logical sense to the user. It has to do with the relationship between the spatial or functional layout of components. These are the four types of constraints that can be utilized by designers to make their UI more beneficial and helpful for the user."}),"\n",(0,o.jsx)("img",{src:n(1328).A}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.br,{}),"\n","Norman, Donald A. The Design of Everyday Things. The MIT Press, 2013."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},1328:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/LegoMotorcycle-137ba0490704c08bf637933456ad84cd.jpg"},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var o=n(6540);const s={},i=o.createContext(s);function a(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);